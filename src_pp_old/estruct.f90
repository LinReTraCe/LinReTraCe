module Mestruct
  use Mparams
  use Mtypes
  implicit none

  contains

subroutine estruct_init(kmesh, edisp, thdr, dos, sct)
  implicit none

  type(kpointmesh) :: kmesh  ! contains k-point mesh specifiers and logical switches on how to get the mesh from
  type(energydisp) :: edisp  ! contains the band dispersion energy and the optical matrix elements (when which > 2) along the irr-k-mesh
  type(tetramesh)  :: thdr   ! contains the tetrahedra (should you need them...)
  type(dosgrid)    :: dos
  type(scatrate)   :: sct


  call getdisp (kmesh, edisp)

  if (algo%ldmft) then
     call getdmft(kmesh, edisp)
  endif

  ! read in the optical matrix elements
  if (algo%loptic) then
    call getopt (kmesh, edisp)
  endif

  call gendosel (kmesh, edisp, dos) ! normalization already taken care of
  call findef(dos, edisp)   ! finds the (non-interacting) Fermi level

  ! get electronic structure
  ! if (algo%ltbind) then
  !    call gentbstr(kmesh, edisp) ! tb on [0, 1) or [0, 1]
  ! else
  ! endif

  ! create tetrahedrons if necessary
  ! evaluate DOS / NOS for the non-interacting case
  ! find Fermi level as a starting point for the full calculation
  !if (algo%ltetra) then
  !   if (.not. algo%ltbind) then
  !      call genfulkm(kmesh, edisp) ! w2k [0, 1) -> [0, 1]
  !   endif
  !   call gentetra(kmesh, thdr)       ! generates the tetrahedra
  !   call intetra (kmesh, edisp, thdr, dos) ! computes the dos and the integrated dos
  !   if (algo%imurestart == 0) call findef(dos, edisp)   ! finds the (non-interacting) Fermi level
  !else
  !   !brute force summation for the DOS, with each
  !   !Dirac's delta replaced by a Lorentzian bandshape
  !endif

  ! now we have a k and e(k) grid on either
  !
  !       | kmesh         | tetrahedrons
  !       v               v
  ! the reducible or the full Brillouin zone

end subroutine !estruct_init



!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! GETDISP
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! This subroutine extracts from the Wien2k struct and energy
! information about the irreducible k-mesh, this is stored
! either in the kpointmesh or in edisp type
!

subroutine getdisp (kmesh, edisp)
  implicit none

  !passed variables
  type(kpointmesh) :: kmesh  ! k-mesh generated by Wien2k
  type(energydisp) :: edisp  ! energy dispersion and optical matrix elements over k-mesh generated by Wien2k
  !internal variables
  integer          :: icrap, itmp, nband, nband_loc, i, j, ik, ix
  integer          :: lines
  integer          :: iatm !number of non-equivalent atoms in cell
  integer          :: stat
  integer          :: id1, id2
  integer          :: ktest(3)
  real(8)          :: sum_multiplicity
  real             :: rcrap
  character(100)   :: ccrap ! this works for arbitrary size
  double precision :: dtmp
  double precision, allocatable :: band_tmp(:,:)    ! bigger datastructure that will contain all the energy dispersion curves
  character(len=33) :: substring_outputkgen = "internal and cartesian k-vectors:"
  character(len=37) :: substring_scf        = "TOTAL VALENCE CHARGE INSIDE UNIT CELL"
  character(len=150) :: line

  ! extract klist information
  ! -> number of kpoints
  ! -> space group identifier
  ! -> identifier: primitive, face, body, base
  ! -> lattice constants
  ! -> lattice vectors
  open(10,file=trim(adjustl(algo%mysyst))//'.klist',status='old')
  ! we simply count the lines here
  lines = 0
  do
     read(10,'(A)') ccrap
     if (lines==0) then
       id1 = index(ccrap, '(')
       id2 = index(ccrap, ')')
       read(ccrap(id1+1:id2-1),*) ktest(1), ktest(2), ktest(3)
       kmesh%kx = ktest(1)
       kmesh%ky = ktest(2)
       kmesh%kz = ktest(3)
       ! if (kmesh%kx /= ktest(1) .or. kmesh%ky /= ktest(2) .or. kmesh%kz /= ktest(3)) then
       !    write(*,*) "GETDISP: INCONSISTENT K-MESH"
       !    write(*,*) "INPUT:     ", kmesh%kx, kmesh%ky, kmesh%kz
       !    write(*,*) "EXTRACTED: ", ktest
       !    STOP
       ! endif
     endif
     if (index(ccrap, "END") .eq. 1) exit ! the klist ends with an END statement
     lines = lines + 1
  enddo
  rewind(10)
  close(10)
  kmesh%ktot = lines
  kmesh%kred = kmesh%kx*kmesh%ky*kmesh%kz
  write(*,*) 'GETDISP: total number of k-points read from W2k: ',kmesh%ktot
  write(*,*) 'GETDISP: total number of k-points in the reducible BZ: ',kmesh%kred

  allocate(kmesh%k_coord(3,kmesh%ktot))
  allocate(kmesh%multiplicity(kmesh%ktot))
  allocate(kmesh%weight(kmesh%ktot))

  open(10,file=trim(adjustl(algo%mysyst))//'.klist',status='old')
  do i = 1, kmesh%ktot
    read(10,*) icrap, icrap, icrap, icrap, icrap, rcrap
    kmesh%multiplicity(i) = rcrap
  enddo

  sum_multiplicity = sum(kmesh%multiplicity)

  if (abs(sum_multiplicity - kmesh%kx*kmesh%ky*kmesh%kz) > 1e-3) then
    write(*,*) "GETDISP: sum of multiplicity: ", sum_multiplicity, " differs from #k-points", &
               kmesh%kx*kmesh%ky*kmesh%kz
    STOP
  else
     kmesh%weight = kmesh%multiplicity / sum_multiplicity
  endif



  !get the number of nonequivalent atoms in cell
  open(10,file=trim(adjustl(algo%mysyst))//'.struct',status='old')
  read(10,*)
  read(10,*) symm%cntr, ccrap, ccrap, iatm , lat%spacegroup
  ! lat%spacegroup = 220
  ! write(*,*) "WARNING: SPACEGROUP HAS BEEN FIXED"
  read(10,*)
  read(10,'(A)') line
  read(line(:10),*)   lat%a(1)
  read(line(11:20),*) lat%a(2)
  read(line(21:30),*) lat%a(3)
  read(line(31:40),*) lat%angle(1)
  read(line(41:50),*) lat%angle(2)
  close(10)


  lat%lortho = .false. !extra identifier
  select case (lat%spacegroup)
    case(1:2) ! triclinic
       lat%ibravais = 14
       lat%vol = lat%a(1)*lat%a(2)*lat%a(3)*sqrt(1.d0 - cos(lat%angle(1))**2 &
                 -cos(lat%angle(2))**2 - cos(lat%angle(3))**3 + 2.d0*cos(lat%angle(1) &
                 *lat%angle(2) * lat%angle(3)))
    case(3:15) !monoclinic
       select case (symm%cntr)
          case('P  ')
             lat%ibravais = 12
          case default
             lat%ibravais = 13
       end select
       ! find the 90 degree angle to apply volume formula
       if (abs(lat%angle(1) - 90.d0) .gt. 1.d-3) then
          lat%vol = lat%a(1)*lat%a(2)*lat%a(3) * sin(lat%angle(1))
       else if (abs(lat%angle(2) - 90.d0) .gt. 1.d-3) then
          lat%vol = lat%a(1)*lat%a(2)*lat%a(3) * sin(lat%angle(2))
       else
          lat%vol = lat%a(1)*lat%a(2)*lat%a(3) * sin(lat%angle(3))
       endif
    case(16:74) !orthorhombic
       lat%lortho = .true.
       select case (symm%cntr)
          case('P  ')
             lat%ibravais = 6
          case('B  ')
             lat%ibravais = 8
          case('F  ')
             lat%ibravais = 9
          case default
             lat%ibravais = 7
       end select
       lat%vol = lat%a(1)*lat%a(2)*lat%a(3)
    case(75:142) ! tetragonal
       lat%lortho = .true.
       select case (symm%cntr)
          case('P  ')
             lat%ibravais = 4
          case default
             lat%ibravais = 5
       end select
       lat%vol = lat%a(1)*lat%a(2)*lat%a(3)
    case(143:194) ! hexagonal - rhombohedral
       select case(symm%cntr)
          case('P  ')
             lat%ibravais = 10
             lat%vol = lat%a(1)*lat%a(2)*lat%a(3) * sin(pi/3.d0)
          case default
             lat%ibravais = 11
             lat%vol = lat%a(1)*lat%a(2)*lat%a(3) * (1.d0 - cos(lat%angle(1))) &
                       * sqrt(1.d0 + 2.d0*cos(lat%angle(1)))
       end select
    case(195:230) ! cubic
       lat%lortho = .true.
       select case(symm%cntr)
          case('P  ')
             lat%ibravais = 1
          case('B  ')
             lat%ibravais = 2
          case('F  ')
             lat%ibravais = 3
       end select
       lat%vol = lat%a(1)*lat%a(2)*lat%a(3)
    end select

  write(*,*) 'GETDISP: number of inequivalent atoms in cell: ',iatm
  write(*,*) 'GETDISP: space group: ', lat%spacegroup
  write(*,*) 'GETDISP: internal bravais identifier: ', lat%ibravais
  write(*,*) 'GETDISP: volume of unit cell: ', lat%vol

  ! get k-points coord's and energy dispersion curves
  open(11,file=trim(adjustl(algo%mysyst))//'.energy',status='old')
  do i=1,2*iatm
     read(11,*)
  enddo
  edisp%nband_max=0
  do ik=1,kmesh%ktot
     read(11,*) rcrap, rcrap, rcrap, icrap, icrap, nband_loc, rcrap
     ! write(*,*) "GETDISP: k-point local number of bands: ", nband_loc

     ! allocate and initialise the temporary array
     if (.not. allocated (band_tmp)) then
        allocate(band_tmp(kmesh%ktot,2*nband_loc))
        band_tmp(:,:) = band_fill_value  !set the band dispersion to a large value
     endif

     if (nband_loc .gt. edisp%nband_max) edisp%nband_max=nband_loc

     ! this check has to be already made here
     if (edisp%nband_max .gt. size(band_tmp,2)) then
        write(*,*) 'GETDISP: you are trying to access energy bands that have not been stored by Wien2k'
        STOP
     endif

     do nband=1,nband_loc
        read(11,*) icrap, band_tmp(ik,nband)
     enddo
  enddo
  !done reading the energy dispersion curves
  close(11)


  ! get the INTERNAL k-vectors
  open(12,file=trim(adjustl(algo%mysyst))//'.outputkgen',status='old')
  ix = 0
  do
     read(12,'(A)', iostat = stat) line
     if (stat == 0) then
        ix = index(line, substring_outputkgen)
        if (ix /= 0) exit
     else
        exit
     endif
  enddo

  if (ix == 0) then
     write(*,*) 'GETSYMOP: error reading file *.outputkgen'
     STOP
  endif

  do i=1,kmesh%ktot
    read(12,*) kmesh%k_coord(1,i), kmesh%k_coord(2,i), kmesh%k_coord(3,i), rcrap, rcrap, rcrap
  enddo
  close(12)



  ! get number of valence electrons
  open(12,file=trim(adjustl(algo%mysyst))//'.scf',status='old')
  do
     read(12,'(A)', iostat = stat) line
     if (stat == 0) then
        ix = index(line, substring_scf)
        if (ix /= 0) exit
     else
        exit
     endif
  enddo

  if (ix == 0) then
     write(*,*) 'GETDISP: error reading file *.scf'
     STOP
  else
    read(line(48:),*) edisp%nelect
  endif
  write(*,*) 'GETDISP: number of valence elctrons: ', edisp%nelect

  !now fill in the actual data structure by cropping band_tmp
  if (.not. allocated(edisp%band) ) allocate(edisp%band(kmesh%ktot,edisp%nband_max))
  ! we intialize everything with thie band_fill_value
  ! reason: different k-points have different number of bands
  ! becaues WIEN2K simply cuts off at a specific energy
  edisp%band = band_fill_value
  do ik=1,kmesh%ktot
     do nband=1,edisp%nband_max
        edisp%band(ik,nband) = band_tmp(ik,nband)
     enddo
  enddo

  deallocate(band_tmp)

end subroutine



! TODO : this has to be generalized
! with spin-orbit coupling we additionally have complex offdiagonal terms 7...9
! order is userdefined by wien2k
! force an order?
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! GETOPT
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! This subroutine extracts from the Wien2k files
! information about the optical matrix elements,
! this is stored in the edisp type variable Mopt
! the first column runs over the polarisation index
! with a convention consistent with the optic module
! in Wien2k, namely:
! 1...Re<x><x>
! 2...Re<y><y>
! 3...Re<z><z>
! 4...Re<x><y>
! 5...Re<x><z>
! 6...Re<y><z>
! columns 4-6 are allocated only for non-cubic systems.
! If DMFT reference state is used the one-particle energies
! are overwritten and self-energy data are read in.
!

subroutine getopt (kmesh, edisp)
  implicit none
  !passed variables
  type(kpointmesh) :: kmesh
  type(energydisp)      :: edisp

  !internal variables
  integer :: icrap, itmp, i, j, ik, nb
  integer :: ierr
  integer :: nband, nband_loc, min_nopt, max_nopt
  real :: rcrap
  character(len=6) :: ccrap
  double precision :: dtmp
  double precision, allocatable :: Mopt_tmp(:,:,:,:)  ! temporary matrices where the Wien2k optical matrices are stored


  ! read in the data into the temporary array
  ! and determine the optical interval size
  if (algo%loptic) then

     ! allocate and initialise the temporary arrays
     ! on the full band interval
     if (lat%lortho) then
        allocate(Mopt_tmp(3,kmesh%ktot,edisp%nband_max,edisp%nband_max))
     else
        allocate(Mopt_tmp(6,kmesh%ktot,edisp%nband_max,edisp%nband_max))
     endif
     Mopt_tmp=0.d0

     open(10,file=trim(adjustl(algo%mysyst))//'.symmat',status='old')
     read(10,*)   !there is a heading line specifying which component of M is printed on file

     edisp%nbopt_min=1000
     edisp%nbopt_max=0
     do ik=1,kmesh%ktot
        read(10,*)   !there is an empty line
        read(10,*)ccrap,itmp,ccrap,ccrap,ccrap,min_nopt,max_nopt
        read(10,*)   !there is an empty line

        !sanity tests
        if ( itmp .ne. ik) then
           write(*,*) 'GETOPT: there is a mismatch between k-points in case.energy and case.symmat'
           STOP
        endif
        if ( max_nopt .gt. edisp%nband_max) then
           write(*,*) 'GETOPT: there are more bands computed in the optical routine than we have energies for'
           STOP
        endif

        !identify the smallest min_nopt and the biggest max_nopt
        if (edisp%nbopt_min .gt. min_nopt) edisp%nbopt_min = min_nopt
        if (edisp%nbopt_max .lt. max_nopt) edisp%nbopt_max = max_nopt
        ! (basically I want the M matrices to have the same size for all the k-points considered)
        !read the matrix elements
        if (lat%lortho) then
           do i=min_nopt,max_nopt
              do j=i,max_nopt
                 read(10,130)icrap,icrap,Mopt_tmp(1,ik,i,j),Mopt_tmp(2,ik,i,j),Mopt_tmp(3,ik,i,j)
              enddo
           enddo
        else
           do i=min_nopt,max_nopt
              do j=i,max_nopt
                 read(10,160)icrap, icrap, Mopt_tmp(1,ik,i,j),Mopt_tmp(2,ik,i,j),Mopt_tmp(3,ik,i,j),&
                   Mopt_tmp(4,ik,i,j),Mopt_tmp(5,ik,i,j),Mopt_tmp(6,ik,i,j)
              enddo
           enddo
        endif

     enddo !over kpoints

     if ((.not. allocated(edisp%Mopt)) .and. (lat%lortho) ) &
       & allocate(edisp%Mopt(3,kmesh%ktot,edisp%nbopt_min:edisp%nbopt_max,edisp%nbopt_min:edisp%nbopt_max))
     if ((.not. allocated(edisp%Mopt)) .and. (.not. lat%lortho) ) &
       & allocate(edisp%Mopt(6,kmesh%ktot,edisp%nbopt_min:edisp%nbopt_max,edisp%nbopt_min:edisp%nbopt_max))

     if (lat%lortho) then
        itmp=3
     else
        itmp=6
     endif

     do ik=1,kmesh%ktot
        do i=1,itmp
           edisp%Mopt(i,ik,edisp%nbopt_min:edisp%nbopt_max,edisp%nbopt_min:edisp%nbopt_max)=&
             & Mopt_tmp(i,ik,edisp%nbopt_min:edisp%nbopt_max,edisp%nbopt_min:edisp%nbopt_max)
        enddo
     enddo

     deallocate(Mopt_tmp)

  else ! non optical -> we simply take all bands
     edisp%nbopt_min=1
     edisp%nbopt_max=edisp%nband_max

     if (.not. allocated(edisp%Mopt)) then
       allocate(edisp%Mopt(3,kmesh%ktot,edisp%nbopt_min:edisp%nbopt_max,edisp%nbopt_min:edisp%nbopt_max))
     endif

     write(*,*) 'GETOPT: setting Mopt = 0'
     ! write(*,*) 'GETOPT: size Mopt =',size(edisp%Mopt,1)

     edisp%Mopt = 0.d0

     ! do nb=edisp%nbopt_min,edisp%nbopt_max
     !    do ik=1,size(edisp%Mopt, 2)
     !       do i = 1,3
     !          edisp%Mopt(i,ik,nb,nb)=1.0d0
     !       enddo
     !    enddo
     ! enddo

  endif

  write(*,*) 'GETOPT: optical bands minimum: ', edisp%nbopt_min
  write(*,*) 'GETOPT: optical bands maximum: ', edisp%nbopt_max

  130  FORMAT (4X,I3,X,I3,3(X,E12.6))
  160  FORMAT (4X,I3,X,I3,6(X,E12.6))
  close(10)



  !allocation of renormalised bandstructure
  !the -Im{Sigma} read in here is added to the temperature dependent scattering rate
  !in the response module

  ! these arrays could have been already allocated by getdmft
  ! if (.not. allocated(edisp%Z)) then
  !    allocate(edisp%Z(kmesh%ktot,edisp%nband_max))
  !    edisp%Z=edisp%ztmp
  ! endif
  ! if (.not. allocated(edisp%Im)) then
  !    allocate(edisp%Im(kmesh%ktot,edisp%nband_max))
  !    edisp%Im=0.0d0
  ! endif

end subroutine

  subroutine getdmft(kmesh, edisp)
    implicit none
    type(kpointmesh) :: kmesh
    type(energydisp)      :: edisp

    integer ik, i, j, min_nopt, max_nopt

    ! since we completely overwrite the quasiparticle renormalizations
    ! we have to set them first to 1 again
    if (.not. allocated(edisp%Z))  allocate(edisp%Z(kmesh%ktot,edisp%nband_max))
    if (.not. allocated(edisp%Im)) allocate(edisp%Im(kmesh%ktot,edisp%nband_max))
    edisp%Z  = 1.d0
    edisp%Im = 0.d0

    open(11,file=trim(adjustl(algo%mysyst))//'.dmft',status='old')
    ! read(11,*) ek%efer
    read(11,*)
    do ik=1,kmesh%ktot
       read(11,*) i, min_nopt, max_nopt
       !sanity checks
       if ( (min_nopt < edisp%nbopt_min) .or. (max_nopt > edisp%nbopt_max) ) then
          write(*,*) 'GETDMFT: Self-energy bands do not match optical matrix elements'
          stop
       endif
       !overwrite the bandstructure with the renormalised one
       !we get new energy levels due to the (back-folded) self-energy shifts from DMFT
       do j=min_nopt,max_nopt
          read(11,*) edisp%band(ik,j), edisp%Z(ik,j), edisp%Im(ik,j)
       enddo
    enddo
    close(11)
  end subroutine getdmft


!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!SUBROUTINE GENDOSEL
! Generates the Density of States starting
! from the Wien2k eigenvalues
! by replacing the Dirac's delta with Lorentzians
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine gendosel(kmesh, edisp, dos)
    implicit none

    type(kpointmesh) :: kmesh
    type(energydisp)      :: edisp
    type(dosgrid)    :: dos
    !local variables
    integer :: i, ik, ikk, nb !energy, k-point, band counters
    integer :: iband
    double precision :: br, de !broadening, energy spacing
    double precision :: maxenergy

    ! we hide this interval search here
    maxenergy=0.d0
    do iband=1,edisp%nband_max
       ! band_fill_value is large enough that we don't have to worry about it in the tb case
       if ((edisp%band(1,iband) < band_fill_value) .and. (maxenergy < abs(edisp%band(1,iband)))) then
          maxenergy = abs(edisp%band(1,iband))
       endif
    enddo
    dos%emax= 2.d0*maxenergy
    dos%emin=-dos%emax
    dos%nnrg=5001

    allocate (dos%enrg(dos%nnrg),dos%dos(dos%nnrg),dos%nos(dos%nnrg))
    dos%enrg= 0.d0
    dos%dos = 0.d0
    dos%nos = 0.d0
    ! get the energy increment along the window fixed in the dos datatype
    de=(dos%emax-dos%emin)/(real(dos%nnrg-1))
    do i=0,dos%nnrg-1
       dos%enrg(i+1)=dos%emin+(de*real(i))
    enddo
    !broadening twice the energy spacing
    br = 2.0d0*de
    !lorentian bandshape
    do i =1,size(dos%enrg)
       do nb=1,edisp%nband_max
          do ik=1,kmesh%ktot
             ! ikk = symm%symop_id(1,ik)
             if (edisp%band(ik,nb) > band_fill_value) cycle !necessary because big eig'vals
                                                !have been introduced to make matrices square
             dos%dos(i)=dos%dos(i)+((br/pi)*(1.0d0/(((dos%enrg(i)-edisp%band(ik,nb))**2)+(br**2)))) * &
                        kmesh%weight(ik)
             dos%nos(i)=dos%nos(i)+(0.5d0 + ((1.0d0/pi)*atan((dos%enrg(i)-edisp%band(ik,nb))/br))) * &
                        kmesh%weight(ik)
          enddo
       enddo
    enddo

    dos%dos = 2.d0 * dos%dos
    dos%nos = 2.d0 * dos%nos

  end subroutine !GENDOSEL

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! FINDEF
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! This routine finds the Fermi level using the
! dos%nos variable and the number of electrons
! provided as an input
!
subroutine findef(dos, edisp)
  implicit none
  type(dosgrid)    :: dos
  type(energydisp) :: edisp
  !local variables
  integer :: i,j
  integer :: pos
  real(8) :: ntol

  pos = 0
  do i=1,dos%nnrg
     if ( (dos%nos(i) - edisp%nelect) .ge. 0.d0 ) then ! sign changed
       pos = i
       exit
     endif
  enddo

  if (pos > 0) then ! found a changing sign
     if ( abs(dos%nos(pos) - edisp%nelect) .le. abs(dos%nos(pos-1) - edisp%nelect) ) then
        edisp%efer = dos%enrg(pos)
        i = pos
     else
        edisp%efer = dos%enrg(pos-1)
        i = pos-1
     endif
  else
     write(*,*) 'FINDEF: No root found for chemical potential, nelect = ', edisp%nelect
     edisp%efer = 0
     return
  endif

  ! find band gap and valence band maximum, conduction band minimum
  ! with the help of the number of states (nos)
  j = i
  do while(abs(dos%nos(j) - dos%nos(i)) < ntol)
     j = j-1
  enddo
  dos%vbm=dos%enrg(j)

  j = i
  do while(abs(dos%nos(j) - dos%nos(i)) < ntol)
     j = j+1
  enddo
  dos%cbm=dos%enrg(j)

  dos%gap=dos%cbm - dos%vbm
  if (dos%gap < 2.0d-2) dos%gap=0.0d0

end subroutine


end module Mestruct
