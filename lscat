#! /usr/bin/env python

from __future__ import print_function, division, absolute_import
import sys
import logging

import numpy as np

from  scattering.fullscattering import FullScattering
# from scattering import dmftloader

'''
lscat: user script to create more elaborate scattering data
'''

__author__     = 'Matthias Pickem'
__maintainer__ = 'Matthias Pickem'
__email__      = 'matthias.pickem@gmail.com'
__version__    = '0.4'
__status__     = 'Dev'
__license__    = 'GPLv3'
__credits__    = ['Matthias Pickem', 'Emanuele Maggio', 'Jan M. Tomczak']


def main_tempmode():
  ''' load LRTC energy file '''
  scatobj = FullScattering('tb-60-60-60-irr.hdf5')
  spins, nkp, nbands = scatobj.getDependencies()

  ''' define temperature grid in Kelvin - logarithmic steps or linear steps'''
  nt = 100 # steps
  temps = scatobj.defineTemperatures(tmin = 10, \
                                     tmax = 300, \
                                     nt   = nt, \
                                     tlog = True)

  ''' create scattering numpy array '''
  gamma = np.ones((nt, spins, nkp, nbands), dtype=np.float64)
  gamma *= 1e-7

  ''' load the array into the instantiated object '''
  scatobj.defineScatteringRates(gamma)

  ''' create output file '''
  scatobj.createOutput('scattering_file.hdf5')


def main_mumode():
  ''' load LRTC energy file '''
  scatobj = FullScattering('tb-60-60-60-irr.hdf5')
  spins, nkp, nbands = scatobj.getDependencies()

  ''' define chemical potential grid in eV
      if muabs: take the values as they are
      if not muabs: interpret them as difference to mu_DFT '''
  nt = 100 # steps
  mus = scatobj.defineChemicalPotentials(temp = 300, \
                                         mumin = -3, \
                                         mumax = +3, \
                                         nmu   = nt, \
                                         muabs = False)

  ''' create scattering numpy array unit: eV '''
  gamma = np.ones((nt, spins, nkp, nbands), dtype=np.float64)
  gamma *= 1e-7

  ''' create quasi particle weight numpy array: range (0,1] '''
  qpweight = np.ones_like(gamma, dtype=np.float64)
  qpweight *= 0.5 # Z = 0.5 throughout

  ''' load the array into the instantiated object '''
  scatobj.defineScatteringRates(scattering = gamma, \
                                qpweight   = qpweight, \
                                bandshift  = None)

  ''' create output file '''
  scatobj.createOutput('scattering_file.hdf5')

def main_momentum_dependence():
  scatobj = FullScattering('tb-60-60-60-irr.hdf5')
  spins, nkp, nbands = scatobj.getDependencies()
  nt = 100 # steps
  temps = scatobj.defineTemperatures(tmin = 10, \
                                     tmax = 300, \
                                     nt   = nt, \
                                     tlog = True)

  ''' get momentum grid '''
  kgrid = scatobj.getMomentumGrid() # shape: nkp, 3

  ''' create functional dependency for all temperatures, spins and bands '''
  gamma = np.zeros((nt, spins, nkp, nbands), dtype=np.float64)
  gammak = np.sum(np.sin(kgrid*2*np.pi)**2,axis=1)
  gamma[...] = gammak[None,None,:,None]
  gamma /= 3000.
  gamma[gamma<1e-10] = 1e-10 # introduce scattering cut-off

  scatobj.defineScatteringRates(gamma)
  scatobj.createOutput('scattering_file.hdf5')

def main_energy_direct_dependence():
  scatobj = FullScattering('tb-60-60-60-irr.hdf5')
  spins, nkp, nbands = scatobj.getDependencies()
  nt = 100 # steps
  temps = scatobj.defineTemperatures(tmin = 10, \
                                     tmax = 300, \
                                     nt   = nt, \
                                     tlog = True)

  ''' get energy grid and dft mu '''
  energies = scatobj.getEnergies()  # shape: spins, nkp, bands
  mudft    = scatobj.mudft

  ''' define gamma(spin,nkp,band) ... temperature independent
      if we have a direct dependence gamma(k) ~ energy(k)
      we can simply use the direct dependence '''
  gamma = np.zeros((nt, spins, nkp, nbands), dtype=np.float64)
  gamma[0,...]  = (energies-mudft)**2. / 10000.
  gamma[1:,...] = gamma[0,...]

  ''' truncate below 1e-10 eV '''
  gamma[gamma<1e-10] = 1e-10

  scatobj.defineScatteringRates(gamma)
  scatobj.createOutput('scattering_file.hdf5')

def main_energy_generic_dependence():
  scatobj = FullScattering('tb-60-60-60-irr.hdf5')
  spins, nkp, nbands = scatobj.getDependencies()
  nt = 100 # steps
  temps = scatobj.defineTemperatures(tmin = 10, \
                                     tmax = 300, \
                                     nt   = nt, \
                                     tlog = True)

  ''' get energy grid and dft mu '''
  energies = scatobj.getEnergies()  # shape: spins, nkp, bands
  mudft    = scatobj.mudft

  ''' define energy range '''
  enemin = energies.min()
  enemax = energies.max()
  print('min energy: {}\nmax energy: {}'.format(enemin,enemax))
  eneaxis = np.linspace(enemin,enemax,5001)

  ''' define generic gamma(energy)
      this method is necessary when the dependence is not direct
      but indirect via a generic distribution Gamma(epsilon) '''
  gammaeps = (eneaxis-mudft)**2 / 10000.

  try:
    import matplotlib.pyplot
    plt.plot(eneaxis,gammaeps)
    plt.show()
  except:
    pass

  ''' get the mapping eps(spin,nkp,band) <-> axis element '''
  where = np.argmin(np.abs(energies[None,...] - eneaxis[:,None,None,None]), axis=0)

  ''' define gamma(spin,nkp,band) ... temperature independent '''
  gamma = np.zeros((nt, spins, nkp, nbands), dtype=np.float64)
  gamma[0,...]  = gammaeps[where]
  gamma[1:,...] = gamma[0,...]

  ''' truncate below 1e-10 eV '''
  gamma[gamma<1e-10] = 1e-10

  scatobj.defineScatteringRates(gamma)
  scatobj.createOutput('scattering_file.hdf5')

def main_banddependence():
  scatobj = FullScattering('tb-60-60-60-irr.hdf5')
  spins, nkp, nbands = scatobj.getDependencies()
  nt = 100 # steps
  temps = scatobj.defineTemperatures(tmin = 10, \
                                     tmax = 300, \
                                     nt   = nt, \
                                     tlog = True)

  ''' scattering that is k-independent
      nkp <- 1  ... removes k-dependence (saves storage)
      first three bands different to the rest '''
  nkp = 1
  gamma = np.ones((nt, spins, nkp, nbands), dtype=np.float64)
  gamma[:,:,:,:3] = 1e-5
  gamma[:,:,:,3:] = 3e-5

  scatobj.defineScatteringRates(gamma)
  scatobj.createOutput('scattering_file.hdf5')

def main_tempddependence():
  scatobj = FullScattering('tb-60-60-60-irr.hdf5')
  spins, nkp, nbands = scatobj.getDependencies()
  nt = 100 # steps
  temps = scatobj.defineTemperatures(tmin = 10, \
                                     tmax = 300, \
                                     nt   = nt, \
                                     tlog = True)

  ''' define temperature dependence
      remove all momentum and band dependence '''
  nkp = nbands = 1
  gamma = np.zeros((nt, spins, nkp, nbands), dtype=np.float64)
  gammaT = 1e-8 + 1e-10 * temps
  gamma[...] = gammaT[:,None,None,None]

  scatobj.defineScatteringRates(gamma)
  scatobj.createOutput('scattering_file.hdf5')

def setLogger():
  ''' some logging '''
  class log_formatter(logging.Formatter):
    def format(self, record):
      if record.levelname == 'INFO':
        return record.msg
      else:
        return '{}: {}: {}'.format(record.filename, record.levelname, record.msg)
  logger = logging.getLogger()
  logger.setLevel(logging.DEBUG) # root logger
  console = logging.StreamHandler()
  console.setFormatter(log_formatter())
  console.setLevel(logging.INFO) # console logger print INFO, WARNING, ERROR and CRITICAL
  logger.addHandler(console)
  return logger

def main():
  logger = setLogger()
  logger.warning('lscat only serves illustrative purposes (code snippets).')
  logger.warning('Copy lscat_template in your working directory and adjust for your purposes.\n\n')

if __name__ == '__main__':
  main()
