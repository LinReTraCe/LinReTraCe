#! /usr/bin/env python

from __future__ import print_function, division, absolute_import
import sys
import argparse

from structure.aux   import LogFormatter
from postproc.output import *
from postproc.input  import *

'''
lprint: Post-processing of LRTC HDF5 files
'''

__author__     = 'Matthias Pickem'
__maintainer__ = 'Matthias Pickem'
__email__      = 'matthias.pickem@gmail.com'
__version__    = '0.2'
__status__     = 'Dev'
__license__    = 'GPLv3'
__credits__    = ['Matthias Pickem', 'Emanuele Maggio', 'Jan M. Tomczak']

error = lambda string: sys.exit('lprint: {}'.format(string))

def parse_args(args=None):
  parser = argparse.ArgumentParser(
    description='''Argument parser for LRTC input and LRTC output data
           " lprint <file> list " --- list all options
           -------------------------------------------
           " lprint <inputfile> info "         --- structural information of input file
           " lprint -p <inputfile> dos "       --- plot density of states
           -------------------------------------------
           " lprint <outputfile> config "      --- config information of lrtc run
           " lprint -p <outputfile> mu "       --- plot chemical potential of latest lrtc run
           " lprint <outputfile> c-total uyy " --- print total conductivity of spin up in yy direction
           " lprint <outputfile> s-intra xx  " --- print intra seebeck (spin summed) in xx direction''',
    formatter_class=argparse.RawTextHelpFormatter,
    epilog="That's the end of the help")
  parser.add_argument('file',    help='LRTC input/output file')
  parser.add_argument('output',  nargs='+', help='Dataset to print/plot (\'list\' for an overview)')
  parser.add_argument('-c', '--compare', nargs='+', help='Comparison of identical dataset from different LRTC output files')
  parser.add_argument('-g', '--gap',  help='Plot the band gap in combination with mu', default=False, action='store_true')
  parser.add_argument('-s', '--scale', help='Scale all quantities by factor', default=1, type=float)
  parser.add_argument('-p', '--plot', help='Plot the dataset instead', default=False, action='store_true')
  parser.add_argument('-x', '--axis', help='Use alternate axis (T -> beta or mu -> carrier)', default=False, action='store_true')
  parser.add_argument('--imag',   help=argparse.SUPPRESS, default=False, action='store_true') # plot the imaginary parts in addition to the real part
  parser.add_argument('--diag',   help=argparse.SUPPRESS, default=False, action='store_true') # only use the diagonal parts (when no directions supplied
  parser.add_argument('--debug',  help=argparse.SUPPRESS, default=False, action='store_true')

  return parser.parse_args(args)

def directionTransform(string, dims):
  '''
    transform character input into numerical inpot via mapping
    also: pre-check for incorrect characters and incorrect argument lengths
  '''

  prevstring = string
  if len(string)>1 and len(string)<5:
    try:
      string = string.lower()

      ''' replace up and down with 1 and 2 '''
      for char, nmb in zip(['u','d'],['1','2']):
        string = string.replace(char,nmb)

      ''' if nothing is replaced place a 0 in front '''
      if prevstring == string:
        string = '0'+string

      for char, nmb in zip(['x','y','z'],['1','2','3']):
        string = string.replace(char,nmb)
      test = int(string)
      return string
    except:
      raise ValueError("Invalid directional argument: {} -- incorrect direction".format(prevstring))
  raise ValueError("Invalid directional argument: {} -- incorrect argument length".format(prevstring))

if __name__ == '__main__':
  args = parse_args()

  ''' define logging '''
  logger = logging.getLogger()
  logger.setLevel(logging.DEBUG)
  console = logging.StreamHandler()
  console.setFormatter(LogFormatter())
  console.setLevel(logging.DEBUG if args.debug else logging.INFO)
  logger.addHandler(console)

  if args.plot:
    try:
      import matplotlib.pyplot as plt
    except ImportError:
      error('Could not import matplotlib')

  inpobj = outobj = None

  ''' Initiate input / output objects '''
  try:
    inpobj = LRTCinput(args.file)
  except IOError as e1:
    try:
      outobj = LRTCoutput(args.file, altaxis=args.axis)
    except IOError as e2:
      error('\n'+str(e1)+'\n'+str(e2))

  if outobj is not None and args.compare: # restrict to outputobjects
    try:
      compareobjs = [outobj]
      for cmpfile in args.compare:
        if cmpfile == args.file: continue
        compareobjs.append(LRTCoutput(cmpfile, altaxis=args.axis))
    except Exception as e:
      error('\n'+str(e))

  cmd = args.output[0].strip()
  cmdlength = len(args.output)

  ''' settings to give to outputData method -- all have proper default values '''
  settings = type('', (), {})() # magic -- creates empty object
  settings.plot    = args.plot
  settings.imag    = args.imag
  settings.diag    = args.diag
  settings.scale   = args.scale
  settings.compare = args.compare # if option unused default = None

  ''' Output object commands '''
  if outobj is not None:
    try:
      if cmd == 'list':
        outobj.outputList(full=False)
      elif cmd == 'flist':
        outobj.outputList(full=True)
      elif cmd == 'config':
        outobj.outputConfig()
      # elif cmd == 'dos':
      #   if cmdlength == 1:
      #     outobj.outputDOS(args.plot)
      #   else:
      #     broadening = float(args.output[1])
      #     outobj.outputDOS(args.plot, broadening)
      #   if args.plot:
      #     plt.title(outobj.fname)
      #     plt.show()
      else:
        ''' response / quantity plotting / output '''
        if cmdlength == 1:
          if args.compare:
            for cmpobj in compareobjs:
              cmpobj.outputData(cmd, settings)
          else:
            outobj.outputData(cmd, settings)
        else:
          # we iterate through the list and check the following arguments
          for i,icmd in enumerate(args.output):
            try:
              check = int(args.output[i])
              continue
            except:
              try:
                check = directionTransform(args.output[i], outobj.dims)
                continue
              except:
                pass # interpret as command

            # check arguments afterward until we get to an error
            directions = []
            for j in range(i+1,cmdlength):
              try:
                check = int(args.output[j])
                directions.append(args.output[j])
              except:
                try:
                  check = directionTransform(args.output[j], outobj.dims)
                  directions.append(check)
                except:
                  break

            if args.compare:
              for cmpobj in compareobjs:
                cmpobj.outputData(icmd, settings, *directions)
            else:
              outobj.outputData(icmd, settings, *directions)

        ''' finally, do some decorating '''
        if settings.plot:
          plt.xlabel(outobj.axislatex, fontsize=14)
          if outobj.mode == 'mu':
            if args.axis:
              plt.axvline(x=0, ls='--', color='gray') # carrier concentration are differences to 0
            else:
              plt.axvline(x=outobj.mudft, ls='--', color='gray', label=r'$\mu_{\mathrm{DFT}}$') # fermi level
        try:
          if outobj.mode == 'temp' and cmd == 'mu'  and args.plot:
            plt.axhline(y=outobj.mudft, ls='--', color='black', label=r'$\mu_{\mathrm{DFT}}$')
            if args.gap:
              outobj.plotBandgap()
        except:
          pass

        if settings.plot:
          plt.legend(loc='best')
          if not args.compare: plt.title(outobj.fname)
          plt.show()

    except BaseException as e:
      error('\nERROR: '+str(e)+'\n')

  ''' Input object commands '''
  if inpobj is not None:
    try:
      if cmd == 'list':
        inpobj.outputList()
      elif cmd == 'info':
        inpobj.outputStructure()
      elif cmd == 'dos':
        if cmdlength == 1:
          inpobj.outputDOS(args.plot)
        else:
          inpobj.outputDOS(args.plot, *args.output[1:])

        if args.plot:
          plt.title(inpobj.fname)
          plt.show()
      else:
        raise IOError('lrtc input file command not recognized')
    except BaseException as e:
      error('\nERROR: '+str(e)+'\n')
